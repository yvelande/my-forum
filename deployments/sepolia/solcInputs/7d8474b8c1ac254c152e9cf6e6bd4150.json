{
  "language": "Solidity",
  "sources": {
    "contracts/ContentInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract ContentInfo {\n    struct Content {\n        uint256 contentId; // 文章id\n        uint256 userId; // 用户id\n        string title; // 标题\n        string content; // 内容\n        uint256 updateTime; // 更新时间\n        uint256 praiseCount; // 点赞数\n        uint256 contentState; //文章状态  1存在 0删除\n    }\n\n    struct Comment {\n        uint256 contentId; // 文章ID\n        uint256 userId; // 用户ID\n        uint256 commentId; //评论ID\n        string comment; // 评论内容\n        uint256 updateTime; // 评论发表时间\n        uint256 praiseCount; // 赞的数\n        uint256 commentState; // 评论状态  1存在 0删除\n    }\n\n    struct Complain {\n        uint256 complaintId; // 投诉id\n        uint256 contentId; // 文章ID\n        uint256 userId; // 用户ID\n        uint256 commentId; // 评论ID\n        string content; // 投诉内容\n        uint256 updateTime; // 投诉发表时间\n        uint256 complainState; // 评论状态  1存在 0删除\n    }\n\n    struct ReturnContent {\n        string contentId; // 文章id\n        string userId; // 用户id\n        string title; // 标题\n        string content; // 内容\n        string updateTime; // 更新时间\n        string praiseCount; // 点赞数\n        string contentState; //文章状态\n    }\n\n    struct ReturnComment {\n        string contentId; // 文章id\n        string userId; // 用户id\n        string commentId; // 评论id\n        string comment; // 评论内容\n        string updateTime; // 更新时间\n        string praiseCount; // 点赞数\n        string commentState; // 评论状态\n    }\n\n    struct ReturnComplain {\n        string complaintId; // 投诉id\n        string contentId; // 文章ID\n        string userId; // 用户ID\n        string commentId; // 评论ID\n        string content; // 投诉内容\n        string updateTime; // 投诉发表时间\n        string complainState; // 投诉状态\n    }\n\n    mapping(uint256 => Content) public contentMap;\n    uint256[] public contentIds;\n    uint256[] public complainIds;\n    mapping(uint256 => Comment) public commentMap;\n    mapping(uint256 => Complain) public complainMap;\n    mapping(uint256 => uint256[]) public contentComments; // 映射 contentId 到评论数组\n\n    // event UserRegistered(string userId);\n    event ContentCreated(uint256 contentId);\n    event PraiseDone(uint256 praiseCount); //这是对帖子进行评论的内容\n    event CommentCreated(uint256 commentId);\n    event PraiseCommentDone(uint256 praiseCount);\n    event ComplaintCreated(uint256 complaintId);\n\n    function createContent(\n        uint256 _userId,\n        string memory _title,\n        string memory _content\n    ) public {\n        uint256 _contentId = uint256(\n            keccak256(abi.encodePacked(block.timestamp, _userId, _title))\n        );\n        contentMap[_contentId] = Content(\n            _contentId,\n            _userId,\n            _title,\n            _content,\n            block.timestamp,\n            0,\n            1\n        );\n        contentIds.push(_contentId);\n        emit ContentCreated(_contentId);\n    }\n\n    function getContent(\n        uint256 _contentId\n    ) public view returns (ReturnContent memory) {\n        Content memory content = contentMap[_contentId];\n        ReturnContent memory returnContent = ReturnContent(\n            uint256ToString(content.contentId),\n            uint256ToString(content.userId),\n            content.title,\n            content.content,\n            uint256ToString(content.updateTime),\n            uint256ToString(content.praiseCount),\n            uint256ToString(content.contentState)\n        );\n        return returnContent;\n    }\n\n    function updateContent(\n        uint256 _contentId,\n        string memory _title,\n        string memory _content\n    ) public {\n        Content memory contentOld = contentMap[_contentId];\n        contentOld.title = _title;\n        contentOld.content = _content;\n        contentOld.updateTime = block.timestamp;\n        contentMap[_contentId] = contentOld;\n    }\n\n    function deleteContent(uint256 _contentId) public {\n        Content memory contentDelete = contentMap[_contentId];\n        contentDelete.contentState = 0;\n        contentMap[_contentId] = contentDelete;\n    }\n\n    function praiseContent(uint256 _contentId) public {\n        contentMap[_contentId].praiseCount++;\n        emit PraiseDone(contentMap[_contentId].praiseCount);\n    }\n\n    function getAllContent() public view returns (ReturnContent[] memory) {\n        uint256 count = contentIds.length;\n        uint256 existCount = 0;\n        for (uint256 i = 0; i < count; i++) {\n            if (contentMap[contentIds[i]].contentState == 1) {\n                existCount++;\n            }\n        }\n        ReturnContent[] memory allContent = new ReturnContent[](existCount);\n        uint256 index = 0;\n        for (uint256 i = 0; i < count; i++) {\n            if (contentMap[contentIds[i]].contentState == 1) {\n                allContent[index] = getContent(contentIds[i]);\n                index++;\n            }\n        }\n        return allContent;\n    }\n\n    //创建评论\n    function createComment(\n        uint256 _contentId,\n        uint256 _userId,\n        string memory _comment\n    ) public {\n        //记得最后开启\n        // require(\n        //     contentMap[_contentId].contentState == 1,\n        //     \"Content does not exist\"\n        // );\n\n        // Generate comment ID\n        uint256 _commentId = uint256(\n            keccak256(abi.encodePacked(block.timestamp, _contentId, _userId))\n        );\n\n        // Create the comment struct\n        Comment memory comment = Comment(\n            _contentId,\n            _userId,\n            _commentId,\n            _comment,\n            block.timestamp,\n            0, // Initial praise count is 0\n            1 // Comment state is active\n        );\n        commentMap[_commentId] = comment;\n        // // Update the content's comment count\n        contentComments[_contentId].push(_commentId);\n        // Trigger an event\n        emit CommentCreated(_commentId);\n    }\n\n    // 更新评论\n    function updateComment(uint256 _commentId, string memory _comment) public {\n        // 确保评论存在\n        // require(\n        //     commentMap[_commentId].commentState == 1,\n        //     \"Comment does not exist\"\n        // );\n\n        // 更新评论内容\n        Comment memory comment = commentMap[_commentId];\n        comment.comment = _comment;\n        comment.updateTime = block.timestamp;\n        commentMap[_commentId] = comment;\n    }\n\n    // 获取评论\n    function getComment(\n        uint256 _commentId\n    ) public view returns (ReturnComment memory) {\n        // 确保评论存在\n        // require(\n        //     commentMap[_commentId].commentState == 1,\n        //     \"Comment does not exist\"\n        // );\n        Comment memory comment = commentMap[_commentId];\n        ReturnComment memory returnComment = ReturnComment(\n            uint256ToString(comment.contentId),\n            uint256ToString(comment.userId),\n            uint256ToString(comment.commentId),\n            comment.comment,\n            uint256ToString(comment.updateTime),\n            uint256ToString(comment.praiseCount),\n            uint256ToString(comment.commentState)\n        );\n        // 返回评论内容\n        return returnComment;\n    }\n\n    // 删除评论\n    function deleteComment(uint256 _commentId) public {\n        // 确保评论存在\n        // require(\n        //     commentMap[_commentId].commentState == 1,\n        //     \"Comment does not exist\"\n        // );\n\n        // 删除评论\n        Comment memory commentDelete = commentMap[_commentId];\n        commentDelete.commentState = 0;\n        commentMap[_commentId] = commentDelete;\n    }\n\n    function getCommentsByContentId(\n        uint256 _contentId\n    ) public view returns (ReturnComment[] memory) {\n        //contentId对应的评论的数组\n        uint256[] memory commmentArray = contentComments[_contentId];\n        uint256 count = commmentArray.length;\n        uint256 existCount = 0;\n        // 遍历所有评论，统计符合条件的评论数量\n        for (uint256 i = 0; i < count; i++) {\n            if (commentMap[commmentArray[i]].commentState == 1) {\n                existCount++;\n            }\n        }\n        // 创建一个数组用于存储符合条件的评论\n        ReturnComment[] memory comments = new ReturnComment[](existCount);\n        uint256 index = 0;\n        // 遍历所有评论，将符合条件的评论存入数组\n        for (uint256 i = 0; i < count; i++) {\n            if (commentMap[commmentArray[i]].commentState == 1) {\n                comments[index] = getComment(commmentArray[i]);\n                index++;\n            }\n        }\n        // 返回所有评论\n        return comments;\n    }\n\n    function praiseComment(uint256 _commentId) public {\n        // 确保评论存在\n        // require(\n        //     commentMap[_commentId].commentState == 1,\n        //     \"Comment does not exist\"\n        // );\n\n        // 增加评论的赞数\n        // Comment memory comment = commentMap[_commentId];\n        // comment.praiseCount++;\n        commentMap[_commentId].praiseCount++;\n        emit PraiseCommentDone(commentMap[_commentId].praiseCount);\n        // commentMap[_commentId] = comment;\n        // 触发事件\n    }\n\n    function createComplaint(\n        uint256 _contentId,\n        uint256 _userId,\n        uint256 _commentId,\n        string memory _complaintContent\n    ) public {\n        uint256 _complaintId = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp,\n                    _contentId,\n                    _userId,\n                    _commentId\n                )\n            )\n        );\n        complainMap[_complaintId] = Complain(\n            _complaintId,\n            _contentId,\n            _userId,\n            _commentId,\n            _complaintContent,\n            block.timestamp,\n            1 // 投诉状态为存在\n        );\n        complainIds.push(_complaintId);\n        emit ComplaintCreated(_complaintId);\n    }\n\n    function getComplain(\n        uint256 _complaintId\n    ) public view returns (ReturnComplain memory) {\n        // 确保投诉存在\n        // require(\n        //     complainMap[_complaintId].complainState == 1,\n        //     \"Complain does not exist\"\n        // );\n\n        Complain memory complain = complainMap[_complaintId];\n        ReturnComplain memory returnComplain = ReturnComplain(\n            uint256ToString(complain.complaintId),\n            uint256ToString(complain.contentId),\n            uint256ToString(complain.userId),\n            uint256ToString(complain.commentId),\n            complain.content,\n            uint256ToString(complain.updateTime),\n            uint256ToString(complain.complainState)\n        );\n        // 返回投诉内容\n        return returnComplain;\n    }\n\n    // 删除投诉\n    function deleteComplain(uint256 _complainId) public {\n        // 确保投诉存在\n        // require(\n        //     complainMap[_complainId].complainState == 1,\n        //     \"Complain does not exist\"\n        // );\n\n        // 删除投诉\n        Complain memory complainDelete = complainMap[_complainId];\n        complainDelete.complainState = 0;\n        complainMap[_complainId] = complainDelete;\n    }\n\n    // 获取被投诉的内容\n    function getAllComplain() public view returns (ReturnComplain[] memory) {\n        uint256 count = complainIds.length;\n        uint256 complainedCount = 0;\n        for (uint256 i = 0; i < count; i++) {\n            if (complainMap[complainIds[i]].complainState == 1) {\n                complainedCount++;\n            }\n        }\n        ReturnComplain[] memory complainedContent = new ReturnComplain[](\n            complainedCount\n        );\n        uint256 index = 0;\n        for (uint256 i = 0; i < count; i++) {\n            if (complainMap[complainIds[i]].complainState == 1) {\n                complainedContent[index] = getComplain(complainIds[i]);\n                index++;\n            }\n        }\n        return complainedContent;\n    }\n\n    // 将 uint256 类型转换为字符串\n    function uint256ToString(\n        uint256 value\n    ) public pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + (value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/ManageInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./UserInfo.sol\";\nimport \"./ContentInfo.sol\";\nimport \"./TokenERC20.sol\";\n\ncontract ManageInfo {\n    UserInfo public userInfo;\n    ContentInfo public contentInfo;\n    TokenERC20 public tokenInfo;\n\n    // 委员会成员投票结构体\n    struct Vote {\n        uint256 voter; // 投票者地址\n        uint256 complaintId; // 投诉的ID\n        uint256 inSupport; // 是否支持投诉 \"1\"是支持 \"0\"是不支持\"\n    }\n    //委员会成员\n    uint256[] commitMember;\n    // 投票数组\n    mapping(uint256 => Vote[]) complainVotesMap;\n\n    constructor(\n        address _userInfoAddress,\n        address _contentInfoAddress,\n        address _tokenInfoAddress\n    ) {\n        userInfo = UserInfo(_userInfoAddress);\n        contentInfo = ContentInfo(_contentInfoAddress);\n        tokenInfo = TokenERC20(_tokenInfoAddress);\n    }\n\n    function getTopAssetUsers(uint256 count) public returns (uint256[] memory) {\n        uint256[] memory registeredUserId = userInfo.getRegisteredUserId();\n        uint256[] memory assetAmounts = new uint256[](registeredUserId.length);\n\n        for (uint256 i = 0; i < registeredUserId.length; i++) {\n            assetAmounts[i] = tokenInfo.getBalance(\n                userInfo.getUserInfo(registeredUserId[i]).userAddress\n            );\n        }\n\n        // 使用大顶堆找到前11名用户\n        uint256[] memory topUsers = new uint256[](count);\n        uint256[] memory topAssets = new uint256[](count);\n\n        // 建立大顶堆\n        for (uint256 i = 0; i < count && i < registeredUserId.length; i++) {\n            topUsers[i] = registeredUserId[i];\n            topAssets[i] = assetAmounts[i];\n            heapify(topAssets, topUsers, i);\n        }\n\n        // 继续迭代剩余的用户\n        for (uint256 i = count; i < registeredUserId.length; i++) {\n            if (assetAmounts[i] > topAssets[0]) {\n                topAssets[0] = assetAmounts[i];\n                topUsers[0] = registeredUserId[i];\n                heapify(topAssets, topUsers, 0);\n            }\n        }\n\n        return topUsers;\n    }\n\n    // 用于调整堆\n    function heapify(\n        uint256[] memory assets,\n        uint256[] memory users,\n        uint256 root\n    ) internal {\n        uint256 largest = root;\n        uint256 left = 2 * root + 1;\n        uint256 right = 2 * root + 2;\n\n        if (left < assets.length && assets[left] > assets[largest]) {\n            largest = left;\n        }\n\n        if (right < assets.length && assets[right] > assets[largest]) {\n            largest = right;\n        }\n\n        if (largest != root) {\n            (assets[root], assets[largest]) = (assets[largest], assets[root]);\n            (users[root], users[largest]) = (users[largest], users[root]);\n            heapify(assets, users, largest);\n        }\n    }\n\n    function getCommitMembers() public returns (string[] memory) {\n        uint256[] memory topAssetUsers = getTopAssetUsers(3);\n        string[] memory ret = new string[](3);\n        // uint256[] memory registeredUser = userInfo.getRegisteredUserId();\n\n        // // 随机抽取9位用户\n        // uint256[] memory randomUsers = getRandomIds(registeredUser);\n\n        // 将资产排名前11的用户和随机抽取的9位用户的 userRole 改为委员会成员\n        for (uint256 i = 0; i < topAssetUsers.length; i++) {\n            userInfo.changeUserRole(topAssetUsers[i], \"1\");\n            ret[i] = uint256ToString(topAssetUsers[i]);\n        }\n        // for (uint256 i = 0; i < randomUsers.length; i++) {\n        //     userInfo.changeUserRole(randomUsers[i], \"Committee Member\");\n        // }\n        commitMember = topAssetUsers;\n        // 返回委员会成员\n        return ret;\n    }\n\n    function returnCommitMembers() public view returns (string[] memory) {\n        string[] memory ret = new string[](3);\n        // uint256[] memory registeredUser = userInfo.getRegisteredUserId();\n\n        // // 随机抽取9位用户\n        // uint256[] memory randomUsers = getRandomIds(registeredUser);\n\n        // 将资产排名前11的用户和随机抽取的9位用户的 userRole 改为委员会成员\n        for (uint256 i = 0; i < commitMember.length; i++) {\n            ret[i] = uint256ToString(commitMember[i]);\n        }\n        // for (uint256 i = 0; i < randomUsers.length; i++) {\n        //     userInfo.changeUserRole(randomUsers[i], \"Committee Member\");\n        // }\n        return ret;\n    }\n\n    // 辅助函数：从注册用户中随机抽取不重复的九个地址\n    function getRandomIds(\n        uint256[] memory registeredUserAddresses\n    ) internal view returns (uint256[] memory) {\n        require(\n            registeredUserAddresses.length >= 9,\n            \"Insufficient registered users\"\n        );\n\n        uint256[] memory randomAddresses = new uint256[](9);\n        bool[] memory selectedIndices = new bool[](\n            registeredUserAddresses.length\n        );\n        uint256 remainingUsers = registeredUserAddresses.length;\n        uint256 remainingSelections = 9;\n\n        // 使用伪随机数生成器选择随机用户地址\n        while (remainingSelections > 0) {\n            uint256 randomIndex = uint256(\n                keccak256(\n                    abi.encodePacked(\n                        block.timestamp,\n                        block.difficulty,\n                        block.number\n                    )\n                )\n            ) % remainingUsers;\n\n            // 如果选择的索引没有被选中过，则将其添加到随机地址数组中，并标记为已选中\n            if (!selectedIndices[randomIndex]) {\n                randomAddresses[\n                    9 - remainingSelections\n                ] = registeredUserAddresses[randomIndex];\n                selectedIndices[randomIndex] = true;\n                remainingSelections--;\n            }\n\n            // 将已选中的地址移至末尾，避免重复选择\n            if (randomIndex != remainingUsers - 1) {\n                registeredUserAddresses[randomIndex] = registeredUserAddresses[\n                    remainingUsers - 1\n                ];\n            }\n\n            // 缩小可选范围\n            remainingUsers--;\n        }\n\n        return randomAddresses;\n    }\n\n    function isCommitteeMember(uint256 userId) public view returns (bool) {\n        for (uint256 i = 0; i < commitMember.length; i++) {\n            if (commitMember[i] == userId) return true;\n        }\n        return false;\n    }\n\n    // 进行投票\n    function makeVote(\n        uint256 userId,\n        uint256 complainId,\n        uint256 isVote\n    ) public {\n        // // 检查是否为委员会成员\n        // require(\n        //        isCommitteeMember(userId),\n        //     \"Only committee members can vote\"\n        // );\n\n        // 检查用户是否已经投过票\n        // require(\n        //     !hasVoted(userId, complainId),\n        //     \"You have already voted for this complaint\"\n        // );\n\n        // 创建投票对象并添加到投票数组中\n        Vote memory newVote = Vote({\n            voter: userId,\n            complaintId: complainId,\n            inSupport: isVote\n        });\n        complainVotesMap[complainId].push(newVote);\n    }\n\n    // 删除文章\n    function deleteContent(uint256 contentId) public {\n        // 在 ContentInfo 合约中定义了删除文章的函数，可以调用相关函数来删除\n        contentInfo.deleteContent(contentId);\n    }\n\n    // 删除评论\n    function deleteComment(uint256 commentId) public {\n        // 在 ContentInfo 合约中定义了删除评论的函数，可以调用相关函数来删除\n        contentInfo.deleteComment(commentId);\n    }\n\n    // 删除评论\n    function deleteComplain(uint256 complainId) public {\n        // 在 ContentInfo 合约中定义了删除评论的函数，可以调用相关函数来删除\n        contentInfo.deleteComplain(complainId);\n    }\n\n    // 获取投票结果\n    function getVoteResults(\n        uint256 _complaintId\n    ) public view returns (string memory) {\n        uint256 supportCount = 0;\n        uint256 oppositionCount = 0;\n        Vote[] memory votes = complainVotesMap[_complaintId];\n        for (uint256 i = 0; i < votes.length; i++) {\n            if (votes[i].inSupport == 1) {\n                supportCount++;\n            } else {\n                oppositionCount++;\n            }\n        }\n        return uint256ToString(supportCount);\n    }\n\n    // 检查用户是否已经投过票\n    function hasVoted(\n        uint256 _voter,\n        uint256 _complaintId\n    ) internal view returns (bool) {\n        Vote[] memory votes = complainVotesMap[_complaintId];\n        for (uint256 i = 0; i < votes.length; i++) {\n            if (votes[i].voter == _voter) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // 将 uint256 类型转换为字符串\n    function uint256ToString(\n        uint256 value\n    ) public pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + (value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/TokenERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface tokenRecipient {\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes calldata _extraData\n    ) external;\n}\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This generates a public event on the blockchain that will notify clients\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) {\n        totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\n        name = tokenName; // Set the name for display purposes\n        symbol = tokenSymbol; // Set the symbol for display purposes\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(\n        address _spender,\n        uint256 _value\n    ) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(\n        address _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(\n                msg.sender,\n                _value,\n                address(this),\n                _extraData\n            );\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\n        totalSupply -= _value; // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(\n        address _from,\n        uint256 _value\n    ) public returns (bool success) {\n        require(balanceOf[_from] >= _value); // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\n        balanceOf[_from] -= _value; // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance\n        totalSupply -= _value; // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n\n    function getBalance(address userAddress) public view returns (uint256) {\n        return balanceOf[userAddress];\n    }\n}\n"
    },
    "contracts/UserInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ncontract UserInfo {\n    // 定义用户结构体\n    struct User {\n        address userAddress; // 用户钱包地址\n        uint256 userId; // 用户ID\n        string userName; // 用户名\n        string pwd; // 密码\n        string role; // 用户角色\n        uint256 assert; // 用户资产\n        uint256 userState; //用户状态 1存在 0删除\n    }\n\n    struct ReturnUser {\n        address userAddress; // 用户钱包地址\n        string userId; // 用户ID\n        string userName; // 用户名\n        string pwd; // 密码\n        string role; // 用户角色\n        string assert; // 用户资产\n        string userState; //用户状态\n    }\n    // 用户ID到用户结构体的映射\n    mapping(uint256 => User) public userMap;\n    // event UserRegistered(string userId);\n    event UserRegistered(uint256 userId);\n\n    // 已注册用\n    uint256[] registeredUserId;\n\n    // 添加用户函数\n    function createUser(\n        string memory _userName,\n        string memory _pwd,\n        address _userAddress //\n    ) public {\n        // 生成用户ID（使用简单的伪随机数生成函数）\n        uint _userId = uint256(\n            keccak256(abi.encodePacked(block.timestamp, _userName))\n        );\n        // string memory _userId = uint256ToString(userId);\n        // 触发事件\n        User memory newUser = User(\n            _userAddress,\n            _userId,\n            _userName,\n            _pwd,\n            // 普通用户roleID是“0”\n            \"0\",\n            0,\n            1\n        );\n        userMap[_userId] = newUser;\n        registeredUserId.push(_userId);\n        emit UserRegistered(_userId);\n    }\n\n    // 用户登录函数\n    function loginUser(\n        uint256 _userId,\n        string memory _pwd\n    ) public view returns (bool) {\n        return\n            keccak256(abi.encodePacked(userMap[_userId].pwd)) ==\n            keccak256(abi.encodePacked(_pwd));\n    }\n\n    // 查询用户信息函数\n    function getUserInfo(\n        uint256 _userId\n    ) public view returns (ReturnUser memory) {\n        User memory user = userMap[_userId];\n        ReturnUser memory returnUser = ReturnUser(\n            user.userAddress,\n            uint256ToString(user.userId),\n            user.userName,\n            user.pwd,\n            user.role,\n            uint256ToString(user.assert),\n            uint256ToString(user.userState)\n        );\n        return returnUser;\n    }\n\n    // 更改用户角色函数\n    function changeUserRole(uint256 _userId, string memory _role) public {\n        userMap[_userId].role = _role;\n    }\n\n    function updateUserInfo(\n        address userAddress, // 用户钱包地址\n        uint256 userId, // 用户ID\n        string memory userName, // 用户名\n        string memory pwd, // 密码\n        string memory role,\n        uint256 assertUpdate\n    ) public {\n        User memory newUser = User(\n            userAddress,\n            userId,\n            userName,\n            pwd,\n            // 普通用户roleID是“0”\n            role,\n            assertUpdate,\n            userMap[userId].userState\n        );\n        userMap[userId] = newUser;\n    }\n\n    function getRegisteredUserId() public view returns (uint256[] memory) {\n        return registeredUserId;\n    }\n\n    // 将 uint256 类型转换为字符串\n    function uint256ToString(\n        uint256 value\n    ) public pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + (value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}