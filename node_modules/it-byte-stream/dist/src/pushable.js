import deferred, {} from 'p-defer';
import { raceSignal } from 'race-signal';
import {} from './index.js';
class QueuelessPushable {
    readNext;
    haveNext;
    ended;
    nextResult;
    constructor() {
        this.ended = false;
        this.readNext = deferred();
        this.haveNext = deferred();
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    async next() {
        if (this.nextResult == null) {
            // wait for the supplier to push a value
            await this.haveNext.promise;
        }
        if (this.nextResult == null) {
            throw new Error('HaveNext promise resolved but nextResult was undefined');
        }
        const nextResult = this.nextResult;
        this.nextResult = undefined;
        // signal to the supplier that we read the value
        this.readNext.resolve();
        this.readNext = deferred();
        return nextResult;
    }
    async throw(err) {
        this.ended = true;
        if (err != null) {
            this.haveNext.reject(err);
        }
        const result = {
            done: true,
            value: undefined
        };
        return result;
    }
    async return() {
        const result = {
            done: true,
            value: undefined
        };
        await this._push(undefined);
        return result;
    }
    async push(value, options) {
        await this._push(value, options);
    }
    async end(err, options) {
        if (err != null) {
            await this.throw(err);
        }
        else {
            // abortable return
            await this._push(undefined, options);
        }
    }
    async _push(value, options) {
        if (value != null && this.ended) {
            throw new Error('Cannot push value onto an ended pushable');
        }
        // already have a value, wait for it to be read
        if (this.nextResult != null) {
            await this.readNext.promise;
            if (this.nextResult != null) {
                throw new Error('NeedNext promise resolved but nextResult was not consumed');
            }
        }
        if (value != null) {
            this.nextResult = { done: false, value };
        }
        else {
            this.ended = true;
            this.nextResult = { done: true, value: undefined };
        }
        // let the consumer know we have a new value
        this.haveNext.resolve();
        this.haveNext = deferred();
        // wait for the consumer to have finished processing the value and requested
        // the next one or for the passed signal to abort the waiting
        await raceSignal(this.readNext.promise, options?.signal, options);
    }
}
export function pushable() {
    return new QueuelessPushable();
}
//# sourceMappingURL=pushable.js.map