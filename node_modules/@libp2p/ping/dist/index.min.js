(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PPing = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PPing=(()=>{var A=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var W=Object.getOwnPropertyNames;var q=Object.prototype.hasOwnProperty;var H=(n,t)=>{for(var e in t)A(n,e,{get:t[e],enumerable:!0})},K=(n,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of W(t))!q.call(n,o)&&o!==e&&A(n,o,{get:()=>t[o],enumerable:!(r=$(t,o))||r.enumerable});return n};var Y=n=>K(A({},"__esModule",{value:!0}),n);var lt={};H(lt,{PING_PROTOCOL:()=>B,ping:()=>at});var a=class extends Error{code;props;constructor(t,e,r){super(t),this.code=e,this.name=r?.name??"CodeError",this.props=r??{}}};var P="ERR_TIMEOUT";function M(n,t){if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return!1;return!0}var g=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var J=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!J)throw new Error("Non little-endian hardware is not supported");var gt={}.toString;function U(n=32){if(g&&typeof g.getRandomValues=="function")return g.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function x(n){if(isNaN(n)||n<=0)throw new a("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return U(n)}function Q(n){return n[Symbol.asyncIterator]!=null}function Z(n){if(Q(n))return(async()=>{for await(let t of n)return t})();for(let t of n)return t}var C=Z;function b(){let n={};return n.promise=new Promise((t,e)=>{n.resolve=t,n.reject=e}),n}var w=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},m=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new w(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new w(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var T=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function E(n={}){return tt(e=>{let r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function tt(n,t){t=t??{};let e=t.onEnd,r=new m,o,i,u,l=b(),c=async()=>{try{return r.isEmpty()?u?{done:!0}:await new Promise((s,p)=>{i=y=>{i=null,r.push(y);try{s(n(r))}catch(d){p(d)}return o}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{l.resolve(),l=b()})}},f=s=>i!=null?i(s):(r.push(s),o),_=s=>(r=new m,i!=null?i({error:s}):(r.push({error:s}),o)),S=s=>{if(u)return o;if(t?.objectMode!==!0&&s?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return f({done:!1,value:s})},R=s=>u?o:(u=!0,s!=null?_(s):f({done:!0})),X=()=>(r=new m,R(),{done:!0}),j=s=>(R(s),{done:!0});if(o={[Symbol.asyncIterator](){return this},next:c,return:X,throw:j,push:S,end:R,get readableLength(){return r.size},onEmpty:async s=>{let p=s?.signal;if(p?.throwIfAborted(),r.isEmpty())return;let y,d;p!=null&&(y=new Promise((ft,F)=>{d=()=>{F(new T)},p.addEventListener("abort",d)}));try{await Promise.race([l.promise,y])}finally{d!=null&&p!=null&&p?.removeEventListener("abort",d)}}},e==null)return o;let h=o;return o={[Symbol.asyncIterator](){return this},next(){return h.next()},throw(s){return h.throw(s),e!=null&&(e(s),e=void 0),{done:!0}},return(){return h.return(),e!=null&&(e(),e=void 0),{done:!0}},push:S,end(s){return h.end(s),e!=null&&(e(s),e=void 0),o},get readableLength(){return h.readableLength},onEmpty:s=>h.onEmpty(s)},o}function et(n){return n[Symbol.asyncIterator]!=null}function nt(...n){let t=[];for(let e of n)et(e)||t.push(e);return t.length===n.length?function*(){for(let e of t)yield*e}():async function*(){let e=E({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(n.map(async r=>{for await(let o of r)e.push(o)})),e.end()}catch(r){e.end(r)}}),yield*e}()}var D=nt;function L(n,...t){if(n==null)throw new Error("Empty pipeline");if(I(n)){let r=n;n=()=>r.source}else if(k(n)||v(n)){let r=n;n=()=>r}let e=[n,...t];if(e.length>1&&I(e[e.length-1])&&(e[e.length-1]=e[e.length-1].sink),e.length>2)for(let r=1;r<e.length-1;r++)I(e[r])&&(e[r]=ot(e[r]));return rt(...e)}var rt=(...n)=>{let t;for(;n.length>0;)t=n.shift()(t);return t},v=n=>n?.[Symbol.asyncIterator]!=null,k=n=>n?.[Symbol.iterator]!=null,I=n=>n==null?!1:n.sink!=null&&n.source!=null,ot=n=>t=>{let e=n.sink(t);if(e?.then!=null){let r=E({objectMode:!0});e.then(()=>{r.end()},u=>{r.end(u)});let o,i=n.source;if(v(i))o=async function*(){yield*i,r.end()};else if(k(i))o=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return D(r,o())}return n.source};var B="/ipfs/ping/1.0.0";var G="1.0.0",V="ping",z="ipfs";var N="ERR_WRONG_PING_ACK";var O=class{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnTransientConnection;log;constructor(t,e={}){this.components=t,this.log=t.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${e.protocolPrefix??z}/${V}/${G}`,this.timeout=e.timeout??1e4,this.maxInboundStreams=e.maxInboundStreams??2,this.maxOutboundStreams=e.maxOutboundStreams??1,this.runOnTransientConnection=e.runOnTransientConnection??!0,this.handleMessage=this.handleMessage.bind(this)}async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:this.runOnTransientConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(t){this.log("incoming ping from %p",t.connection.remotePeer);let{stream:e}=t,r=Date.now();L(e,e).catch(o=>{this.log.error("incoming ping from %p failed with error",t.connection.remotePeer,o)}).finally(()=>{let o=Date.now()-r;this.log("incoming ping from %p complete in %dms",t.connection.remotePeer,o)})}async ping(t,e={}){this.log("pinging %p",t);let r=Date.now(),o=x(32),i=await this.components.connectionManager.openConnection(t,e),u,l=()=>{};if(e.signal==null){let c=AbortSignal.timeout(this.timeout);e={...e,signal:c}}try{u=await i.newStream(this.protocol,{...e,runOnTransientConnection:this.runOnTransientConnection}),l=()=>{u?.abort(new a("ping timeout",P))},e.signal?.addEventListener("abort",l,{once:!0});let c=await L([o],u,async _=>C(_)),f=Date.now()-r;if(c==null)throw new a(`Did not receive a ping ack after ${f}ms`,N);if(!M(o,c.subarray()))throw new a(`Received wrong ping ack after ${f}ms`,N);return this.log("ping %p complete in %dms",i.remotePeer,f),f}catch(c){throw this.log.error("error while pinging %p",i.remotePeer,c),u?.abort(c),c}finally{e.signal?.removeEventListener("abort",l),u!=null&&await u.close()}}};function at(n={}){return t=>new O(t,n)}return Y(lt);})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
return Libp2PPing}));
